<!DOCTYPE html>
<html>
<head>
    <title>Dietary Patterns in the US</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .category-checkbox {
            margin-right: 10px;
        }
    </style>
       
</head>
<body>

    <!-- Carousel Section -->
    <div class="carousel">
        <!-- Carousel Item 1 -->
        <div class="carousel-item">
            <h2>Dietary Pattern in the US</h2>
            <p></p>
            <p>Explanation of why the website exists.</p>
        </div>
        <!-- Carousel Item 2 -->
        <div class="carousel-item">
            <textarea placeholder="Textbox 1"></textarea>
        </div>
        <!-- Carousel Item 3 -->
        <div class="carousel-item">
            <textarea placeholder="Textbox 2"></textarea>
        </div>
        <!-- Carousel Navigation -->
        <button class="prev" onclick="moveSlide(-1)">Previous</button>
        <button class="next" onclick="moveSlide(1)">Next</button>
    </div>
    
    <!-- Additional Content Section -->
    <div class="additional-content">
        <p>This is where additional content goes.</p>
    </div>



<!-- STARTING THE MAIN PLOT -->

    <h1>Food Nutrient Analysis</h1>
    <p>Analysis of nutrient content in food items.</p>
    <div id="controls"></div>
<svg id="foodChart"></svg>
<div class="tooltip" style="position: absolute; opacity: 0;"></div> <!-- Ensure tooltip has a position for absolute layout -->
<script src="https://d3js.org/d3.v6.min.js"></script>
<script>
    const width = 1200;
    const height = 1200;
    const margin = {top: 60, right: 60, bottom: 200, left: 60};

    const svg = d3.select("#foodChart")
        .attr("width", width)
        .attr("height", height);

    // Move the controls selection before its first use
    const controls = d3.select("#controls");

    // Mapping from nutrients to image URLs
    const nutrientImageMap = {
        'Protein': './images/protein.jpg',
        'Sugar': './images/sugar.jpg',
        'Fat': './images/fat.jpg',
        'Carbohydrates': './images/carbs.jpg',
        // Add more mappings as needed
    };

    d3.csv('./data/average_nutrients.csv').then(function(data) {
        const categories = [...new Set(data.map(d => d.Category))];
        categories.forEach(category => {
            const categoryId = category.replace(/\s+/g, '_');
            controls.append("input")
                .attr("type", "checkbox")
                .attr("id", categoryId)
                .attr("checked", true)
                .on("change", updateVisibility);
            controls.append("label")
                .attr("for", categoryId)
                .text(category);
        });

        // Scale down the images to avoid overlap
        const imageWidth = 80; // Width of the images in pixels
        const imageHeight = 80; // Height of the images in pixels

        // Adjust the yScale to add some padding on top for better visibility
        const yScale = d3.scaleLinear()
            .domain([0, d3.max(data, d => parseFloat(d.Energ_Kcal))])
            .range([height - margin.bottom, margin.top + 20]);

        // Use scaleBand for categorical data on the x-axis
        const xScale = d3.scaleBand()
            .domain(categories) // Use category names as domain
            .range([margin.left, width - margin.right])
            .padding(0.1); // Add some padding between bands

        
        // Append images for each data point
        svg.selectAll("image")
            .data(data)
            .enter()
            .append("image")
            .attr("width", imageWidth)
            .attr("height", imageHeight)
            .attr("xlink:href", function(d) {
                let nutrients = [
                    {type: 'Protein', value: parseFloat(d['Protein_(g)'])},
                    {type: 'Sugar', value: parseFloat(d['Sugar_Tot_(g)'])},
                    {type: 'Fat', value: parseFloat(d['Lipid_Tot_(g)'])},
                    {type: 'Carbohydrates', value: parseFloat(d['Carbohydrt_(g)'])},
                ];
                let dominantNutrient = nutrients.sort((a, b) => b.value - a.value)[0].type;
                return nutrientImageMap[dominantNutrient];
            })
            .attr("x", d => xScale(d.Category))
            .attr("y", d => yScale(parseFloat(d.Energ_Kcal)) - imageHeight) // Adjust y position

        // Add X Axis
        svg.append("g")
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(xScale))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-65)"); // Keep rotation
        
        // Add Y Axis
        svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(yScale))
            .append("text")
            .attr("fill", "#000")
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", "-3.5em")
            .attr("text-anchor", "end")
            .text("Energy (kcal)");

        // Ensure tooltip is only appended once
        const tooltip = d3.select(".tooltip");

        svg.selectAll("image")
            .on("mouseover", (event, d) => {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(getTooltipHtml(d)) // Function to create tooltip HTML content
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", (event, d) => {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

            svg.append("g")
                .attr("class", "grid")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat("")
                );

            svg.selectAll(".grid line")
                .style("stroke", "lightgrey")
                .style("stroke-opacity", "0.7")
                .style("shape-rendering", "crispEdges");
            


                    // If using bars, you can add a color scale
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10); // or any other color scheme

// Then apply this scale to your bars or category labels
svg.selectAll(".bar")
    .style("fill", (d, i) => colorScale(i));


// Add title and axis labels
svg.selectAll("text")
    .style("font-family", "Arial, sans-serif")
    .style("font-size", "12px");

svg.append("text")
    .attr("x", (width / 2))             
    .attr("y", margin.top / 2)
    .attr("text-anchor", "middle")  
    .style("font-size", "24px")
    .style("font-weight", "bold")
    .style("font-family", "Arial, sans-serif")
    .text("Food Nutrient Analysis");



const legend = svg.append("g")
    .attr("font-family", "Arial, sans-serif")
    .attr("font-size", 10)
    .attr("text-anchor", "end")
    .selectAll("g")
    .data(colorScale.domain().slice().reverse())
    .enter().append("g")
    .attr("transform", (d, i) => "translate(0," + i * 20 + ")");

legend.append("rect")
.attr("x", width - 19)
.attr("width", 19)
.attr("height", 19)
.attr("fill", colorScale);

legend.append("text")
.attr("x", width - 24)
.attr("y", 9.5)
.attr("dy", "0.32em")
.text(d => d);


        // Function to update visibility based on checkboxes
        function updateVisibility() {
            const checkedCategories = categories.filter(category => 
                d3.select("#" + category.replace(/\s+/g, '_')).property("checked")
            );
            svg.selectAll("image")
                .style("display", d => checkedCategories.includes(d.Category) ? "inline" : "none");
        }

        // Function to create tooltip HTML content
        function getTooltipHtml(d) {
    return `
        <div style="color: #fff; background: rgba(0, 0, 0, 0.75); padding: 10px; border-radius: 8px; font-family: ComicSansMS, sans-serif;">
            <strong>${d.Category}</strong><br>
            <table style="margin-top: 5px;">
                <tr><td>Protein:</td><td>${d['Protein_(g)']}g</td></tr>
                <tr><td>Sugar:</td><td>${d['Sugar_Tot_(g)']}g</td></tr>
                <tr><td>Fat:</td><td>${d['Lipid_Tot_(g)']}g</td></tr>
                <tr><td>Carbohydrates:</td><td>${d['Carbohydrt_(g)']}g</td></tr>
                <tr><td>Energy:</td><td>${d.Energ_Kcal}kcal</td></tr>
            </table>
        </div>
    `;
}

    });
</script>

<!-- Going to add a line break -->

<br>
<br>

<div id="myDiv">
    <!-- Plotly chart will be drawn inside this DIV -->
    <script>
        // Load the CSV file
        d3.csv('./data/average_nutrients.csv').then(function(data) {
            var categories = data.map(function(d) { return d.Category; });
            var sugarContent = data.map(function(d) { return +d['Sugar_Tot_(g)']; });
            var proteinContent = data.map(function(d) { return +d['Protein_(g)']; });
            var fatContent = data.map(function(d) { return +d['Lipid_Tot_(g)']; });
            var carbContent = data.map(function(d) { return +d['Carbohydrt_(g)']; });
            var energyContent = data.map(function(d) { return +d['Energ_Kcal']; });
    
            var trace1 = {
                x: categories,
                y: sugarContent,
                type: 'bar',
                name: 'Sugar (g)',
                marker: {
                    color: 'rgba(255,99,132,0.6)',
                    line: {
                        color: 'rgba(255,99,132,1.0)',
                        width: 1
                    }
                }
            };
    
            var trace2 = {
                x: categories,
                y: proteinContent,
                type: 'bar',
                name: 'Protein (g)',
                marker: {
                    color: 'rgba(54, 162, 235, 0.6)',
                    line: {
                        color: 'rgba(54, 162, 235, 1.0)',
                        width: 1
                    }
                }
            };
    
            var trace3 = {
                x: categories,
                y: fatContent,
                type: 'bar',
                name: 'Fat (g)',
                marker: {
                    color: 'rgba(255, 206, 86, 0.6)',
                    line: {
                        color: 'rgba(255, 206, 86, 1.0)',
                        width: 1
                    }
                }
            };
    
            var trace4 = {
                x: categories,
                y: carbContent,
                type: 'bar',
                name: 'Carbohydrates (g)',
                marker: {
                    color: 'rgba(75, 192, 192, 0.6)',
                    line: {
                        color: 'rgba(75, 192, 192, 1.0)',
                        width: 1
                    }
                }
            };
    
            var trace5 = {
                x: categories,
                y: energyContent,
                type: 'bar',
                name: 'Energy (Kcal)',
                marker: {
                    color: 'rgba(153, 102, 255, 0.6)',
                    line: {
                        color: 'rgba(153, 102, 255, 1.0)',
                        width: 1
                    }
                }
            };
    
            var data = [trace1, trace2, trace3, trace4, trace5];
    
            var layout = {
                title: 'Nutrient Content by Food Category',
                xaxis: {
                    title: 'Food Category',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Amount',
                    zeroline: false
                },
                barmode: 'group',
                margin: {
                    l: 100,
                    r: 100,
                    t: 100,
                    b: 150
                },
                paper_bgcolor: 'rgb(248,248,255)',
                plot_bgcolor: 'rgb(248,248,255)'
            };
    
            Plotly.newPlot('myDiv', data, layout);
        });
    </script>
    
</div>


<!-- Adding a line break -->
<br>
<div id="bubble-plot">

    <script>
        Plotly.d3.csv('./data/top_10_protein.csv', function(err, rows){
            // Ensure no errors occurred during loading the data
            if(err) throw err;
    
            // Group data by category
            let categoryData = {};
            rows.forEach(row => {
                if (!categoryData[row.Category]) {
                    categoryData[row.Category] = [];
                }
                categoryData[row.Category].push(row);
            });
    
            // Generate a trace for each category
            let traces = Object.keys(categoryData).map(category => {
                let items = categoryData[category];
                return {
                    name: category,
                    x: items.map(item => parseFloat(item['Carbohydrt_(g)'])), // Carbohydrate content
                    y: items.map(item => parseFloat(item['Protein_(g)'])), // Protein content
                    text: items.map(item => item['Shrt_Desc']), // Text displayed when hovering over a bubble
                    mode: 'markers',
                    marker: {
                        size: items.map(item => parseFloat(item['Protein_(g)'])), // Size of the bubbles
                        sizemode: 'diameter', // 'area' or 'diameter'
                        sizeref: 2.0 * Math.max(...items.map(item => parseFloat(item['Protein_(g)']))) / (10**2), // Adjust '30' to scale bubble sizes
                        opacity: 0.6
                    }
                };
            });
    
            let layout = {
                title: 'Protein to Carbohydrate Content in Food Items',
                xaxis: {title: 'Carbohydrates (g)'},
                yaxis: {title: 'Protein (g)'},
                margin: {t: 40},
                hovermode: 'closest',
                showlegend: true
            };
    
            Plotly.newPlot('bubble-plot', traces, layout);
        });
    </script>
</div>


<!-- Adding Protin to Fat -->

<div id="bubble-fat">

    <script>
        Plotly.d3.csv('./data/top_10_protein.csv', function(err, rows){
            // Ensure no errors occurred during loading the data
            if(err) throw err;
    
            // Group data by category
            let categoryData = {};
            rows.forEach(row => {
                if (!categoryData[row.Category]) {
                    categoryData[row.Category] = [];
                }
                categoryData[row.Category].push(row);
            });
    
            // Generate a trace for each category
            let traces = Object.keys(categoryData).map(category => {
                let items = categoryData[category];
                return {
                    name: category,
                    x: items.map(item => parseFloat(item['Lipid_Tot_(g)'])), // Fat content
                    y: items.map(item => parseFloat(item['Protein_(g)'])), // Protein content
                    text: items.map(item => item['Shrt_Desc']), // Text displayed when hovering over a bubble
                    mode: 'markers',
                    marker: {
                        size: items.map(item => parseFloat(item['Protein_(g)'])), // Size of the bubbles
                        sizemode: 'diameter', // 'area' or 'diameter'
                        sizeref: 2.0 * Math.max(...items.map(item => parseFloat(item['Protein_(g)']))) / (10**2), // Adjust '30' to scale bubble sizes
                        opacity: 0.6
                    }
                };
            });
    
            let layout = {
                title: 'Protein to Fat Content in Food Items',
                xaxis: {title: 'Fat (g)'},
                yaxis: {title: 'Protein (g)'},
                margin: {t: 40},
                hovermode: 'closest',
                showlegend: true
            };
    
            Plotly.newPlot('bubble-fat', traces, layout);
        });
    </script>
</div>
<!-- Adding a line break -->

<div id="collate">
    <script>
        d3.csv('./data/top_10_protein.csv').then(function(data) {
            // Assume data is aggregated by category with averages for each nutrient
            var categoryData = aggregateDataByCategory(data); // Pseudocode
    
            var traces = [];
            var nutritionalMetrics = ['Protein_(g)', 'Sugar_Tot_(g)', 'Lipid_Tot_(g)', 'Energ_Kcal', 'Carbohydrt_(g)'];
            var categories = Object.keys(categoryData); // Your categories
    
            categories.forEach(function(category, index) {
                var yValues = nutritionalMetrics.map(metric => categoryData[category][metric]);
                var xValues = nutritionalMetrics; // Using metrics as the x-axis
    
                var trace = {
                    x: xValues,
                    y: yValues,
                    fill: 'tozeroy',
                    type: 'scatter',
                    mode: 'none', // No markers or lines, just the filled area
                    name: category
                };
                traces.push(trace);
            });
    
            var layout = {
                title: 'Nutritional Profile by Category',
                xaxis: { title: 'Nutritional Metric' },
                yaxis: { title: 'Value' },
                showlegend: true
            };
    
            Plotly.newPlot('collate', traces, layout);
        });
    
        // Pseudocode: Implement this function based on your data structure
        function aggregateDataByCategory(data) {
    let categoryAggregates = {};

    // Loop through each data item
    data.forEach(item => {
        let category = item.Category;

        // Initialize category in the aggregate object if not present
        if (!categoryAggregates[category]) {
            categoryAggregates[category] = {
                'Protein_(g)': [],
                'Sugar_Tot_(g)': [],
                'Lipid_Tot_(g)': [],
                'Energ_Kcal': [],
                'Carbohydrt_(g)': [],
                'count': 0 // Count the number of items for averaging later
            };
        }

        // Accumulate values for each metric
        categoryAggregates[category]['Protein_(g)'].push(parseFloat(item['Protein_(g)'] || 0));
        categoryAggregates[category]['Sugar_Tot_(g)'].push(parseFloat(item['Sugar_Tot_(g)'] || 0));
        categoryAggregates[category]['Lipid_Tot_(g)'].push(parseFloat(item['Lipid_Tot_(g)'] || 0));
        categoryAggregates[category]['Energ_Kcal'].push(parseFloat(item['Energ_Kcal'] || 0));
        categoryAggregates[category]['Carbohydrt_(g)'].push(parseFloat(item['Carbohydrt_(g)'] || 0));
        categoryAggregates[category]['count'] += 1;
    });

    // Calculate averages
    Object.keys(categoryAggregates).forEach(category => {
        Object.keys(categoryAggregates[category]).forEach(metric => {
            if (metric !== 'count') {
                let total = categoryAggregates[category][metric].reduce((acc, curr) => acc + curr, 0);
                let avg = total / categoryAggregates[category]['count'];
                categoryAggregates[category][metric] = avg; // Replace the array with its average
            }
        });
        delete categoryAggregates[category]['count']; // Remove the count property
    });

    return categoryAggregates;
}

    </script>
    
</div>


    <!-- Footer -->
    <footer>
        <p>Footer content here.</p>
    </footer>

    <script src="script.js"></script>
<!-- Script to navigate through the Carousel -->
    <script>
        let slideIndex = 1;
showSlides(slideIndex);

function moveSlide(n) {
    showSlides(slideIndex += n);
}

function showSlides(n) {
    let i;
    let slides = document.getElementsByClassName("carousel-item");
    if (n > slides.length) {slideIndex = 1}    
    if (n < 1) {slideIndex = slides.length}
    for (i = 0; i < slides.length; i++) {
        slides[i].style.display = "none";  
    }
    slides[slideIndex-1].style.display = "block";  
}

    </script>


</body>
</html>

